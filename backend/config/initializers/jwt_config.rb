# frozen_string_literal: true

# JWT Token Configuration for Shiojiri Rainbow Seeker API
#
# This initializer defines JWT token settings that complement devise-jwt.
# It provides configuration for the dual-token strategy:
# - Access Token: Short-lived (15 minutes), used for API requests
# - Refresh Token: Long-lived (7 days), used to obtain new access tokens
#
# The access token expiration is configured in devise.rb (jwt.expiration_time).
# This file provides additional configuration for refresh tokens and token validation.

module JwtConfig
  class << self
    # Access token expiration time in seconds (15 minutes)
    # This should match the devise-jwt expiration_time setting
    ACCESS_TOKEN_EXPIRATION = 15.minutes.to_i

    # Refresh token expiration time in seconds (7 days)
    REFRESH_TOKEN_EXPIRATION = 7.days.to_i

    # Algorithm used for JWT signing
    ALGORITHM = "HS256"

    # JWT secret key
    # @return [String] the secret key for JWT signing
    def secret_key
      ENV.fetch("DEVISE_JWT_SECRET_KEY") do
        if Rails.env.production?
          raise "DEVISE_JWT_SECRET_KEY environment variable is required in production"
        else
          Rails.application.secret_key_base || "development-jwt-secret-key-not-for-production"
        end
      end
    end

    # Access token expiration time
    # @return [Integer] expiration time in seconds
    def access_token_expiration
      ACCESS_TOKEN_EXPIRATION
    end

    # Refresh token expiration time
    # @return [Integer] expiration time in seconds
    def refresh_token_expiration
      REFRESH_TOKEN_EXPIRATION
    end

    # Token algorithm
    # @return [String] the algorithm name
    def algorithm
      ALGORITHM
    end

    # Encode a refresh token for a user
    #
    # @param user [User] the user to encode the token for
    # @return [String] the encoded JWT refresh token
    def encode_refresh_token(user)
      payload = {
        sub: user.id,
        jti: SecureRandom.uuid,
        iat: Time.current.to_i,
        exp: (Time.current + refresh_token_expiration).to_i,
        type: "refresh"
      }

      JWT.encode(payload, secret_key, algorithm)
    end

    # Decode and validate a refresh token
    #
    # @param token [String] the JWT refresh token to decode
    # @return [Hash, nil] the decoded payload or nil if invalid
    def decode_refresh_token(token)
      decoded = JWT.decode(
        token,
        secret_key,
        true,
        {
          algorithm: algorithm,
          verify_expiration: true
        }
      )

      payload = decoded.first.with_indifferent_access

      # Verify this is a refresh token
      return nil unless payload[:type] == "refresh"

      # Check if token has been revoked
      return nil if JwtDenylist.exists?(jti: payload[:jti])

      payload
    rescue JWT::ExpiredSignature, JWT::DecodeError, JWT::VerificationError
      nil
    end

    # Revoke a refresh token by adding it to the denylist
    #
    # @param token [String] the JWT refresh token to revoke
    # @return [Boolean] true if revoked successfully
    def revoke_refresh_token(token)
      decoded = JWT.decode(
        token,
        secret_key,
        true,
        {
          algorithm: algorithm,
          verify_expiration: false # Allow revoking expired tokens
        }
      )

      payload = decoded.first.with_indifferent_access
      exp_time = Time.zone.at(payload[:exp])

      JwtDenylist.create!(jti: payload[:jti], exp: exp_time)
      true
    rescue JWT::DecodeError, JWT::VerificationError, ActiveRecord::RecordInvalid
      false
    end

    # Generate both access and refresh tokens for a user
    # Note: Access token is generated by devise-jwt automatically
    # This method is for generating the refresh token alongside
    #
    # @param user [User] the user to generate tokens for
    # @return [Hash] hash containing refresh_token and expires_at
    def generate_refresh_token(user)
      {
        refresh_token: encode_refresh_token(user),
        refresh_expires_at: (Time.current + refresh_token_expiration).iso8601
      }
    end
  end
end

# Freeze the module to prevent modifications
JwtConfig.freeze
